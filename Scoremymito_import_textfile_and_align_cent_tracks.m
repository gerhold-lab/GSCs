% WINDOWS VERSION that works with last version of .txt generated by
% trackmate
% group tifs into folders based on whatever unifying theme makes sense (i.e. L4440, control, ani-2?) and which you want to compile data for into a single analysis
% name each tif with acquisition date, condition/genotype and 'gonadX' e.g.
% '2018_04_10_L4440_gonad1.tif'
% generate TrackMate .txt file with centrosome coordinates and save in same directory with same file name (i.e. '2018_04_10_L4440_gonad1.txt')
% end result: folder with 1 tif and 1 txt per gonad, all with the same root name

% This scropt also generates 2 additional txt files with the coordinates to
% feed into ImageJ, which allow us to crop out each individual cell based
% on the position of it's spindle midpoint.

%uigetdir Open folder selection dialog box
folder = uigetdir;
fileList = getAllFiles(folder);

% Find all the .txt files in 'fileList'
% Because this script generates extra txt files in the starting directory,
% if you must re-run this script we will want to ignore these txt files
% which we do by removing all text files with the coords and cellIDs names
boo = strfind(fileList,'txt');
coo = strfind(fileList,'coords');
goo = strfind(fileList,'cellIDs');

%cellfun Apply function to each cell in cell array
%TF = isempty(A) returns logical 1 (true) if A is an empty array and logical 0 (false) otherwise.
foo = find(~cellfun('isempty', boo) & cellfun('isempty', coo) & cellfun('isempty', goo));
TrackMate_fileList = fileList(foo, 1);

% Use 'TrackMate_fileList' to loop through all TrackMate files, import
% centrosome coordinates, and calculate spindle
% length. Final output will be a structure array organized as follows: output(1,x).gonad = gonad name,
% output(1,x).cell = cell number, output(1,x).meas = numeric array organized as follows:
    % UPDATED
    %       col 1 = frames (corrected such that 0 = 1)   
    %       col 2 = POSITION_T
    %       col 3 = spindle length
    %       col 4-6 = x, y, z coords of spindle midpoint
    %       col 7-9 = spindle vector

A = exist('Celloutput');
if A ~= 1
    Celloutput = struct;
    kk = 1;
else
    [~,kk] = size(Celloutput);
end

B = exist('Germlineoutput');
if B ~= 1
    Germlineoutput = struct;
    zz = 1;
else
    [~,zz] = size(Germlineoutput);
end
 
for i = 1:1:length(TrackMate_fileList)
    % when i = 1, size(output) = [1,1]
    % returns the number of rows and columns
    [rr, cc] = size(Celloutput);
    [rrr, ccc] = size(Germlineoutput);
    TrackMate = TrackMate_fileList{i,1};
    mm = strfind(TrackMate, '\'); % change to '\' for Windows OS
    gnd2 = TrackMate(1, (mm(1,length(mm))+1):length(TrackMate));
    nn = strfind(gnd2, '.');
    % 'gonad' should = gonad name (e.g. '2018_04_10_L4440_gonad1')
    % used to name csv/xlsx file and corresponding folder of stl files
    gonad = gnd2(1, 1:(nn(1,length(nn))-1)); 
    
    % On Windows OS xlsread should read the CSV, but on Mac OS xlsread can only
    % recognize XLS, XLSX, XLSM, XLTX, and XLTM.
    %[num,txt,raw] = xlsread(TrackMate);
    
    %We want to make this work for txt files so that we donèt need to rely
    %on xlsread, which only works if we have excel
    
    M = readtable(TrackMate);
    
    % Pull out the centrosome IDs (i.e. Label) from TrackMate output = SpotIDs.
    spotIDs = table2cell(M(1:end,1));
    
    % boo = cell array of same dimensions as SpotIDs, where each cell is 1 if the
    % SpotID string starts with 'Cent' or empty if SpotID string does not. This
    % step is necessary to exclude any spots that were not part of a track, but
    % not deleted (will be called 'IDxxxx'). Will also exclude spots for which
    % the ID/label was not changed to 'Cent_xx'.
    boo = strfind(spotIDs,'Cent');

    % foo = numeric array with row indices for all rows in spotIDs which have a
    % properly labelled centrosome (i.e. 'Cent_xx')
    foo = find(~cellfun('isempty', boo));
    
    % centIDs = cell array with all of the proper centrosome IDs/labels
    centIDs = spotIDs(foo, 1);
    
    % centIDs_unique = cell array with each unique centrosome ID/label, sorted
    % length(centIDs_unique) == 2 x number of cells analyzed
    centIDs_unique = unique(centIDs);
    if mod(length(centIDs_unique),2) ~= 0
        error(['Number of centrosomes is not even for ', gonad, '. Check TrackMate file.'])
    end

    % centIdx = cell array with each cell containing a numeric array that
    % contains the row indices in SpotIDs for each centrosome (i.e.
    % centIdx{1,1} = row indices for Cent_1a). numbcents = numeric array with
    % the number of times that each centrosome appears in SpotIDs
    centIdx = cell(1,length(centIDs_unique));
    numbcents = zeros(1,length(centIDs_unique));
    for j = 1:1:length(centIDs_unique)
        sam = centIDs_unique{j,1};
        bob = strfind(spotIDs, sam);
        centIdx{1,j} = find(~cellfun('isempty', bob));
        numbcents(1,j) = length(centIdx{1,j});
    end

    % Because centIDs_unique is sorted, the centrosomes should be arranged in
    % pairs in both centIdx and numbcents (i.e. numbcents(1,1) and
    % numbcents(1,2) should be for Cent_1a and Cent_1b, respectively). If no
    % errors were made during tracking, numbcents(1,1) == numbcents(1,2).
    jon = zeros(1,length(centIDs_unique));
    for j = 1:2:length(centIDs_unique)
        jon(1,j) = isequal(numbcents(1,j),numbcents(1,j+1));
    end
    jon = jon(1,1:2:end);
    luc = find(~jon);
    if isempty(luc) == 0
        for k = 1:1:length(luc)
            ab = centIDs_unique{luc(1,k)*2,1};
            aa = centIDs_unique{(luc(1,k)*2)-1,1};
            warning(['Number of spots does not match for ', aa, ' and ', ab, ' in ', gonad, '.'])
        end
    end

    % cent_cords = cell array where row 1 contains the centrosome ID/label and
    % row 2 contains a matrix for each centrosome with the x, y, z and t
    % coordinates (columns 6, 7, 8 and 10 from TrackMate output). 
    % Values are pulled from the 'M' output of readtable.
    
    cent_cords = centIDs_unique';
    for j = 1:1:length(centIDs_unique)
        indx = centIdx{1,j};
        gg = table2array(M(indx,[5:9]));
        % add sort step to make sure that all centrosomes are ordered by
        % frame
        [~,hh] = sort(gg(:,5));
        cent_cords{2,j} = gg(hh,:);
    end
    
    % Add a step to align the tracks for pairs of centrosomes by frame -
    % this will compare the numeric arrays exported from the 'M' output
    % for pairs of centrosomes, create a frame index based on the min and max frame number for 
    % both centrosomes and align the measured values for each centrosome to this index
    % This will account for skipped frames in tracking.
    
    for j = 1:2:length(cent_cords)
        aa = cent_cords{1,j};
        bb = cent_cords{1,j+1};
        CentA = cent_cords{2,j};
        CentB = cent_cords{2, j+1};
        [mA, ~] = size(CentA);
        [mB, ~] = size(CentB);
        boo = min([nanmin(CentB(:,5)), nanmin(CentA(:,5))]);
        foo = max([nanmax(CentB(:,5)), nanmax(CentA(:,5))]);
        FrIndx = [boo:1:foo]';
        % unique returns all the unique frame values for CentA/B in sorted
        % order. Use to make sure there are no frames with > 1 spot
        moo = unique(CentA(:,5));
        Ncount = histc(CentA(:,5), moo);
        loo = moo(Ncount ~= 1);
        mooB = unique(CentB(:,5));
        NcountB = histc(CentB(:,5), mooB);
        looB = mooB(NcountB ~= 1);
        if isempty(loo) && isempty(looB)
            boo = NaN(length(FrIndx),5);
            boo(:,5) = FrIndx;
            for k = 1:1:length(FrIndx)
                if sum(CentA(:,5)==boo(k,5)) == 1;
                    boo(k,1:4) = CentA(CentA(:,5)==boo(k,5),1:4);
                end
            end
            cent_cords{3,j} = boo;
            boo = NaN(length(FrIndx),5);
            boo(:,5) = FrIndx;
            for k = 1:1:length(FrIndx)
                if sum(CentB(:,5)==boo(k,5)) == 1;
                    boo(k,1:4) = CentB(CentB(:,5)==boo(k,5),1:4);
                end
            end
            cent_cords{3,j+1} = boo;
        elseif ~isempty(loo)
            frameerrors = num2str(loo);
            error(['For ', aa, ' in ', gonad, ' there is more than 1 spot per a frame at ', frameerrors '. Check TrackMate file.'])
        elseif ~isempty(loo)
            frameerrors = num2str(loo);
            error(['For ', bb, ' in ', gonad, ' there is more than 1 spot per a frame at ', frameerrors '. Check TrackMate file.'])
        end
    end
 
    % Pull out frame and time values for all cells in gonad being processed and adjust frames by 1
    frames = NaN(max(numbcents),length(centIDs_unique));
    time = NaN(max(numbcents),length(centIDs_unique));
    for j = 1:2:length(centIDs_unique)
        aa = cent_cords{3,j}(:,5);
        frames(1:length(aa),j) = aa+1;
        time(1:length(cent_cords{3,j}(:,4)),j) = cent_cords{3,j}(:,4);
    end
    frames = frames(:,1:2:end);
    %frames(~frames)=NaN;
    time = time(:,1:2:end);
    
    % Calculate the spindle length for each pair of centrosomes over time.
    % Script will crash at this point if not all centrosome pairs have the same
    % number of spots.
    spin_length = NaN(max(numbcents),length(centIDs_unique));
    for j = 1:2:length(centIDs_unique)
        aa = cent_cords{3,j}(:,1:3);
        ab = cent_cords{3,j+1}(:,1:3);
        spin_length(1:length(aa),j) = sqrt(sum((ab-aa).*(ab-aa),2));
    end
    spin_length = spin_length(:,1:2:end);
    %spin_length(~spin_length)=NaN;
    
    % Calculate the spindle midpoint for and vector between each pair of centrosomes over time.
    % Script will crash at this point if not all centrosome pairs have the same
    % number of spots.
    spin_midpnt = cell(1,length(centIDs_unique));
    spin_vec = cell(1,length(centIDs_unique));
    for j = 1:2:length(centIDs_unique)
        aa = cent_cords{3,j}(:,1:3);
        ab = cent_cords{3,j+1}(:,1:3);
        spin_midpnt{1,j} = (ab+aa)./2;
        spin_vec{1,j} = ab-aa;
    end
    spin_midpnt = spin_midpnt(:,1:2:end);
    spin_vec = spin_vec(:,1:2:end);
    
    % make cell array with cell IDs for gonad being processed
    cellIDs = cell(1,length(centIDs_unique));
    for j = 1:2:length(centIDs_unique)
        cellID = cent_cords{1,j};
        cellID = cellID(1:length(cellID)-1);
        cellID = strrep(cellID, 'Cent', 'Cell');
        cellIDs{1,j} = cellID;
    end
    cellIDs = cellIDs(1,1:2:end);
    
    % Find the total number of frames tracked for each cell using the aligned
    % tracked from cent_cords. This allows for import into output without
    % using ~isnan and thus permits NaN filled gaps in tracks
    [aa, bb] = size(cent_cords);
    for j = 1:2:bb
        [m, ~] = size(cent_cords{3,j});
        frametotal(1,j) = m;
    end
    frametotal = frametotal(1,1:2:end);
    
    % put data for each cell into output structure array
    for j = 1:1:length(cellIDs)
        if i == 1 && kk == 1
            Celloutput(j).gonad = gonad;
            Celloutput(j).cell = cellIDs{1,j};
            Celloutput(j).meas(1:frametotal(1,j),1) = frames(1:frametotal(1,j),j);
            Celloutput(j).meas(1:frametotal(1,j),2) = time(1:frametotal(1,j),j);
            Celloutput(j).meas(1:frametotal(1,j),3) = spin_length(1:frametotal(1,j),j);
            Celloutput(j).meas(1:frametotal(1,j),4:6) = spin_midpnt{1,j};
            Celloutput(j).meas(1:frametotal(1,j),7:9) = spin_vec{1,j};
        else
            Celloutput(j+cc).gonad = gonad;
            Celloutput(j+cc).cell = cellIDs{1,j};
            Celloutput(j+cc).meas(1:frametotal(1,j),1) = frames(1:frametotal(1,j),j);
            Celloutput(j+cc).meas(1:frametotal(1,j),2) = time(1:frametotal(1,j),j);
            Celloutput(j+cc).meas(1:frametotal(1,j),3) = spin_length(1:frametotal(1,j),j);
            Celloutput(j+cc).meas(1:frametotal(1,j),4:6) = spin_midpnt{1,j};
            Celloutput(j+cc).meas(1:frametotal(1,j),7:9) = spin_vec{1,j};
        end
    end
    Germlineoutput(zz).gonad = gonad;
    Germlineoutput(zz).numdivs = length(cellIDs);
    Germlineoutput(zz).lastframe = max(max(frames));
    Germlineoutput(zz).cells = cellIDs;
    
    % Generate a ImageJ-readable file to create ROIs and crop out all
    % tracked cells
    cells = cell(sum(frametotal),1);
    coords = NaN(sum(frametotal),4);
    for j = 1:1:length(cellIDs)
        if j == 1
            boo = 1;
            foo = frametotal(j);
        else
            boo = find(cellfun('isempty',cells),1);
            foo = boo + frametotal(j)-1;
        end
        cells(boo:foo,1) = cellIDs(1,j);
        coords(boo:foo,1) = frames(1:frametotal(j),j);
        coords(boo:foo,2:4) = spin_midpnt{1,j};
    end
    cells = cells(~isnan(coords(:,2)),:);
    coords = coords(~isnan(coords(:,2)),:);
    Germlineoutput(zz).IJcells = cells;
    Germlineoutput(zz).IJcoords = coords;
    
    %output a tab-delimited text file with spindle midpoint coordinates and
    %cell IDs to open in ImageJ
    coords = num2cell(coords);
    jan = [cells, coords];
    jan = jan';
    jill = replace(TrackMate,'.txt','_coords');
    output_file = [jill '.txt'];
    fileID = fopen(output_file,'w');
    fprintf(fileID,'%4s\t%5s\t%1s\t%1s\t%1s\n','Cell','Frame','X','Y','Z');
    fprintf(fileID,'%6s\t%2d\t%6.4f\t%6.4f\t%5.4f\n',jan{:});
    fclose(fileID);
    %create second output with list of unique cell IDs to use as an index
    %in ImageJ macro
    jill = replace(TrackMate,'.txt','_cellIDs');
    output_fileb = [jill '.txt'];
    fileID = fopen(output_fileb,'w');
    fprintf(fileID,'%6s\n',cellIDs{:});
    fclose(fileID);
    zz = zz + 1;
end
